---
title: "Mocking the Universe"
slug: "mocking-the-universe"
date: "2023-01-02T09:40:12-05:00"
draft: false
image: img/blog/2023-03-08-mocking-the-universe/monkey-in-mirror.jpg
author: DanielSollis
category: Golang, Programming, gRPC
profile: img/team/daniel-sollis.png
description: ""
---

Here at rotational as you might know, we use gRPC and protocol buffers [quite](https://rotational.io/blog/documenting-grpc-with-openapi) [a bit,](https://rotational.io/blog/what-are-protocol-buffers/) and while gRPC is extremely useful for specifying and implementing network APIs it does raise the question: How do we integrate gRPC with one of our other favorite practices, [mocking?] (https://rotational.io/blog/fake-it-when-you-make-it/) Let's find out!

<!--more-->

## Package Mocks
One of the main reasons using mocks is that they allow you to get around dependencies. If you are testing a piece of code you want to test THAT piece of code, not every dependency it's using as well. The same goes for code using gRPC, you don't want to have to test the entire `gRPC service` as well as the network (which can be unreliable) when a piece of code calls an RPC. But how can we avoid stepping into the implementation details when testing? 

The easiest way to get around this is to avoid gRPC all together using package mocks. In many cases, different gRPC service calls are isolated into their own packages that contain structs (likely a `gRPC client` or a struct containing the client) that implement the service's procedure calls. By mocking these structs you can avoid not only the `gRPC calls`, but any other dependencies that might show up in the service's implementation.

## Creating A Package Mock

Lets imagine we have the following service defined:

```proto
syntax = "proto3";

service Database {
    rpc Get(GetRequest) returns (GetReply) {};
    rpc Put(PutRequest) returns (PutReply) {};
}
```

In our `Database package`, likely under database/database.go we might have the following struct defined:

```golang
type Database struct {
    conf database.config
    client DatabaseNetworkClient
}
```

This struct will take care of all of the service's RPC implementation and will also take care of any state (such as configuration or caching) that the service requires. If we add a new interface that the `Database` struct implements:

```golang
type DatabaseInterface {
    Get(GetRequest) GetReply
    Put(PutRequest) PutReply
}
```

We can now start defining a package mock that will allow us to circumvent calls to the Database service by creating a new struct that also implements `DatabaseInterface`. 

```golang
const (
    MockDatabaseGet = "MockDatabase specified error on call to Get"
    MockDatabasePut = "MockDatabase specified error on call to Put"
)

type MockDatabase struct {
    Calls      map[string]int 
	ErrorOn    string
}

func NewMockDatabase(conf) *MockDatabase {
	return &MockDatabase{
		Calls: make(map[string]int),
	}
}

func (d *MockDatabase) Get(context.Context, GetRequest) (*GetReply) {
	d.Calls[MockDatabaseGet]++
	if d.ErrorOn == MockPeersGet {
		return nil, errors.New(d.ErrorOn)
	}
	return &GetReply{
        Success: true
    }, nil
}

func (d *MockDatabase) Put(context.Context, PutRequest) (*PutReply) {
	d.Calls[MockDatabasePut]++
	if d.ErrorOn == MockPeersGet {
		return nil, errors.New(d.ErrorOn)
	}
	return &PutReply{
        Success: true
    }, nil
}
```

The fields we've added to the mock struct are particularly useful. By using the Calls map you can easily make sure that the number of calls you expect have actually happened and with the ErrorOn field you can easily cause any RPC call to fail when needed for testing. 

This approach works perfectly for testing code that uses the package that we are mocking, but what about testing the package itself? The package will contain the actual RPC calls, and is going to require a different method.

## Bufconn
When testing a package that implements a `gRPC service` we seemingly won't be able to get around having to deal with RPC calls, which bring with them all of the complications of dealing with an unreliable network and whatever dependencies are part of the RPC handling code on the other side of the network. Fortunately for us gRPC comes with a built in solution, the [Bufconn package.](https://pkg.go.dev/google.golang.org/grpc/test/bufconn)

Bufconn provides a way to get around the network dependency by creating an in-memory buffer that simulates a real `gRPC connection`. What about the service at the other end of the connection though? Doesn't that still have dependencies that we don't want to deal with? Well, we can mock it! With the combination of `Bufconn` and mocking we can test code that makes calls to `gRPC`, a technique we've been calling `Universal Mocking`.

## Universal mock
Let's go back to our original `Database` definition:

```golang
type DatabaseInterface {
    Get(GetRequest) GetReply
    Put(PutRequest) PutReply
}

type Database struct {
    conf database.config
    client database.DatabaseNetworkClient
}
```

In order to test this struct we'll need to create a mocked server with bufconn that this struct's client can connect to, this will be the Universal mock, and will look something like this:

```golang
type RemoteDatabase struct {
	conn        *bufconn.Listener
    srv         *grpc.Server
    Calls       map[string]int
    OnGet       func(context.Context, GetRequest) (*GetReply, error)
    OnPut       func(context.Context, PutRequest) (*PutRequest, error)
}
```

This looks a lot like the Package mock with a few modifications. We keep the `Calls` map to count specific RPC calls but add a bufconn and `grpc.Server` to serve with. The `OnGet` and `OnPut` field's type is a bit odd and we'll go over those later. Creating a new `RemoteDatabase` will be a bit different than with the package mock:

```golang
func NewRemoteDatabase() *RemoteDatabase {
	database := &RemoteDatabase{
		conn:  bufconn.Listen(bufsize),
		srv:   grpc.NewServer(),
		Calls: make(map[string]int),
	}
	pb.RegisterDatabaseNetworkServer(database.srv, database)
	go database.Serve()
	return database
}

func (r *RemoteDatabase) Serve() {
	if err := r.srv.Serve(r.conn); err != nil {
		fmt.Println(err.Error())
	}
}

func (r *RemoteDatabase) ClientOptions() (opts []grpc.DialOption) {
	// Create the dialer
	dialer := func(context.Context, string) (net.Conn, error) {
		return r.conn.Dial()
	}
	opts = append(opts, grpc.WithContextDialer(dialer))

	// Disable transport security
	opts = append(opts, grpc.WithInsecure())

	return opts
}
```

In the `NewRemoteDatabase` function we have to instantiate a new bufconn and gRPC server that we need to register and serve. We also have an additional function for serving with the gRPC server and a method for returning the preferred gRPC.DialOptions to make connecting to the mocked server easier. The final piece of the puzzle is the RPC implementations, this is were those odd field types from before come in:

```golang
func (r *RemoteDatabase) Get(ctx context.Context, in GetRequest) (out *GetReply, err error) {
	r.Calls[GetRPC]++
	return r.OnGet(ctx, in)
}

func (r *RemoteDatabase) Put(ctx context.Context, in PutRequest) (out *PutRequest, err error) {
	r.Calls[PutRPC]++
	return r.OnPut(ctx, in)
}
```

The use of the `Calls` field is largely the same as with the package mock, but we are basically just calling the functions stored on the `OnGet and OnPut` fields. Because these store functions this allows us to specify whatever functionality that we want the server to have for these RPCs!
for example if we want the server to simply return an empty reply:

```golang
mock := NewRemoteDatabase()
mock.OnGet = func(context.Context, GetRequest) (*GetReply, error) {
	return &GetReply{}, nil
}
reply := mock.Get()
```

 Putting all of this together we get a Universal Mock: 

```golang
const(
    GetRPC  = "Database/Get"
	PutRPC  = "Database/Put"
	bufsize = 1024 * 1024
)

type RemoteDatabase struct {
	conn        *bufconn.Listener
    srv         *grpc.Server
    Calls       map[string]int
    OnGet       func(context.Context, GetRequest) (*GetReply, error)
    OnPut       func(context.Context, PutRequest) (*PutRequest, error)
}

func NewRemoteDatabase() *RemoteDatabase {
	database := &RemoteDatabase{
		conn:  bufconn.Listen(bufsize),
		srv:   grpc.NewServer(),
		Calls: make(map[string]int),
	}
	pb.RegisterDatabaseNetworkServer(database.srv, database)
	go database.Serve()
	return database
}

func (r *RemoteDatabase) Serve() {
	if err := r.srv.Serve(r.conn); err != nil {
		fmt.Println(err.Error())
	}
}

func (r *RemoteDatabase) ClientOptions() (opts []grpc.DialOption) {
	// Create the dialer
	dialer := func(context.Context, string) (net.Conn, error) {
		return r.conn.Dial()
	}
	opts = append(opts, grpc.WithContextDialer(dialer))

	// Disable transport security
	opts = append(opts, grpc.WithInsecure())

	return opts
}

func (r *RemoteDatabase) Get(ctx context.Context, in GetRequest) (out *GetReply, err error) {
	r.Calls[GetRPC]++
	return r.OnGet(ctx, in)
}

func (r *RemoteDatabase) Put(ctx context.Context, in PutRequest) (out *PutRequest, err error) {
	r.Calls[PutRPC]++
	return r.OnPut(ctx, in)
}
```

## Connecting the Universal Mock

The last step is to have the `Database` struct's client to the Universal Mock. We need to add a method to the struct that handles connecting to a gRPC server:

```golang
func (d *Database) Connect(opts ...grpc.DialOption) (err error) {
	if d.client != nil {
		return nil
	}

	var cc *grpc.ClientConn
	if cc, err = grpc.Dial("bufnet", opts...); err != nil {
		return fmt.Errorf("could not dial database service: %s", err)
	}

	d.client = NewDatabaseNetworkClient(cc)
	return nil
}
```

With this method in place creating and connecting to a Universal Mock becomes easy as can be:

```golang
remoteDatabase := NewRemoteDatabase()
err = database.Connect(remoteDatabase.ClientOptions()...)
```
