---
title: "Mocking the Universe"
slug: "mocking-the-universe"
date: "2023-01-02T09:40:12-05:00"
draft: true
author: DanielSollis
image: img/blog/num215.jpg
category: Golang, Programming, gRPC
profile: img/team/daniel-sollis.png
description: ""
---

Here at rotational as you might know, we use gRPC and protocol buffers [quite](https://rotational.io/blog/documenting-grpc-with-openapi) [a bit,](https://rotational.io/blog/what-are-protocol-buffers/) and while gRPC is extremely useful for specifying and implementing network APIs it does raise the question: How do we integrate gRPC with one of our other favorite practices, [mocking?] (https://rotational.io/blog/fake-it-when-you-make-it/) Let's find out!

<!--more-->

## Package Mocks
One of the main reasons using mocks is that they allow you to get around dependencies. If you are testing a piece of code you want to test THAT piece of code, not every dependency it's using as well. The same goes for code using gRPC, you don't want to have to test the entire `gRPC service` as well as the network (which can be unreliable) when a piece of code calls an RPC. But how can we avoid stepping into the implementation details when testing? 

The easiest way to get around this is to avoid gRPC all together using package mocks. In many cases, different gRPC service calls are isolated into their own packages that contain structs (likely a `gRPC client` or a struct containing the client) that implement the service's procedure calls. By mocking these structs you can avoid not only the `gRPC calls`, but any other dependencies that might show up in the service's implementation.

## Creating A Package Mock

Lets imagine we have the following service defined:

```proto
syntax = "proto3";

service Database {
    rpc Get(GetRequest) returns (GetReply) {};
    rpc Put(PutRequest) returns (PutReply) {};
}
```

In our `Database package`, likely under database/database.go we might have the following struct defined:

```golang
type Database struct {
    conf database.config
    client database.DatabaseNetworkClient
}
```

This struct will take care of all of the service's RPC implementation and will also take care of any state (such as configuration or caching) that the service requires. If we add a new interface that the `Database` struct implements:

```golang
type DatabaseInterface {
    Get(GetRequest) GetReply
    Put(PutRequest) PutReply
}
```

We can now start defining a package mock that will allow us to circumvent calls to the Database service by creating a new struct that also implements `DatabaseInterface`. 

```golang
const (
    MockDatabaseGet = "MockDatabase specified error on call to Get"
    MockDatabasePut = "MockDatabase specified error on call to Put"
)

type MockDatabase struct {
    conf database.config
    Calls      map[string]int 
	ErrorOn    string
}

func (d *MockDatabase) Get(context.Context, GetRequest) (*GetReply) {
	d.Calls[MockDatabaseGet]++
	if d.ErrorOn == MockPeersGet {
		return nil, errors.New(d.ErrorOn)
	}
	return &GetReply{
        Success: true
    }, nil
}

func (d *MockDatabase) Put(context.Context, PutRequest) (*PutReply) {
	d.Calls[MockDatabasePut]++
	if d.ErrorOn == MockPeersGet {
		return nil, errors.New(d.ErrorOn)
	}
	return &PutReply{
        Success: true
    }, nil
}
```

The fields we've added to the mock struct are particularly useful. By using the Calls map you can easily make sure that the number of calls you expect have actually happened and with the ErrorOn field you can easily cause any RPC call to fail when needed for testing. 

This approach works perfectly for testing code that uses the package that we are mocking, but what about testing the package itself? The package will contain the actual RPC calls, and is going to require a different method.

## Bufconn
When testing a package that implements a `gRPC service` we seemingly won't be able to get around having to deal with RPC calls, which bring with them all of the complications of dealing with an unreliable network and whatever dependencies are part of the RPC handling code on the other side of the network. Fortunately for us gRPC comes with a built in solution, the [Bufconn package.](https://pkg.go.dev/google.golang.org/grpc/test/bufconn)

Bufconn provides a way to get around the network dependency by creating an in-memory buffer that simulates a real `gRPC connection`. What about the service at the other end of the connection though? Doesn't that still have dependencies that we don't want to deal with? Well, we can mock it! With the combination of `Bufconn` and mocking we can test code that makes calls to `gRPC`, a technique we've been calling `Universal Mocking`.

## Universal mock
Let's go back to our original `Database` definition:

```golang
type DatabaseInterface {
    Get(GetRequest) GetReply
    Put(PutRequest) PutReply
}

type Database struct {
    conf database.config
    client database.DatabaseNetworkClient
}
```



```golang
const(
    GetRPC  = "Database/Get"
	PutRPC  = "Database/Put"
	bufsize = 1024 * 1024
)

type RemoteDatabase struct {
    pb.UnimplementedDatabaseNetworkServer
	conn        *bufconn.Listener
    Calls       map[string]int
    OnGet       func(context.Context, GetRequest) (*GetReply, error)
    OnPut       func(context.Context, PutRequest) (*PutRequest, error)
}

func (r *RemoteDatabase) Get(ctx context.Context, in GetRequest) (out *GetReply, err error) {
	r.Calls[GetRPC]++
	return r.OnGet(ctx, in)
}

func (r *RemoteDatabase) Put(ctx context.Context, in PutRequest) (out *PutRequest, err error) {
	r.Calls[PutRPC]++
	return r.OnPut(ctx, in)
}
```