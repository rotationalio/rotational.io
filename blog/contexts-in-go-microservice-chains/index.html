<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Contexts in Go Microservice Chains</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Contexts are a critical part of services implemented in Golang, but although we see them often in server interfaces, they can be a bit mysterious to developers implementing request handlers. In this post, we look at a specific example where contexts shine: handlers that have to call multiple internal microservices to serve their response."><meta name=author content="Rotational Labs, LLC"><meta name=generator content="Hugo 0.81.0"><link rel=stylesheet href=https://rotational.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://rotational.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://rotational.io/plugins/magnific-popup/magnific-popup.css><link rel=stylesheet href=https://rotational.io/plugins/slick/slick.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento+Sans:400,700&display=swap"><link rel=stylesheet href=https://rotational.io/css/style.min.css media=screen><link rel=stylesheet href=https://rotational.io/css/custom.min.css media=screen><link rel="shortcut icon" href=https://rotational.io/images/favicon.png type=image/x-icon><link rel=icon href=https://rotational.io/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-2FKX6CWJHW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-2FKX6CWJHW')</script></head><body id=body data-spy=scroll data-target=.navbar data-offset=55><div id=content><section class="sticky-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-dark"><a class="navbar-brand p-0" href=/><img class=lozad data-src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a>
<button class="navbar-toggler rounded-0" type=button data-toggle=collapse data-target=#navigation>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://rotational.io/#about>about</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#services>services</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#team>team</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/blog>blog</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#contact>contact</a></li></ul><select id=select-language onchange="location=this.value"><option id=en value=https://rotational.io/blog/contexts-in-go-microservice-chains/ selected>En</option></select></div></nav></div></section><section class=section><div class=container><div class=row><div class="col-lg-8 offset-lg-2 text-center"><h1>Contexts in Go Microservice Chains</h1><ul class="list-inline mb-50"><li class=list-inline-item><a href=/author/benjamin-bengfort/>Benjamin Bengfort</a></li><li class=list-inline-item>Sunday, May 2, 2021</li></ul><img class="img-fluid mb-50 lozad" data-src=https://rotational.io/images/blog/arboreal.jpg alt=blog-image></div><div class="col-lg-8 offset-lg-2"><div class=post-single-content><p>Contexts are a critical part of services implemented in Golang. Although we see them often in server interfaces, they can be mysterious to developers implementing request handlers. In this post, we&rsquo;ll discuss what contexts are and take a look at a specific example where contexts shine: services that are implemented as a series of microservice requests. Then we&rsquo;ll dive into the tl;dr of contexts — namely, the two crucial rules that all service handlers should implement. Finally, we&rsquo;ll demonstrate a quick experiment using gRPC to show how context deadlines are propagated to downstream microservices during request processing, enabling effective coordination.</p><p>The code for the experiment can be found at: <a href=https://github.com/rotationalio/ctxms>github.com/rotationalio/ctxms</a>.</p><h2 id=contexts-in-service-handlers>Contexts in Service Handlers</h2><p>If you&rsquo;ve implemented a gRPC API you&rsquo;ll know that the RPC interface for a request handler has a function signature that looks something like:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (s *Server) <span style=color:#447fcf>MyRPC</span>(ctx context.Context in *Request) (out *Reply, err <span style=color:#6ab825;font-weight:700>error</span>) {}
</code></pre></div><p>The first argument is always a <code>context.Context</code>, which if you&rsquo;re like me, you think of as &ldquo;the thing with the deadline for the client&rdquo;. However, if you&rsquo;re also like me, 90% of the time you simply ignore it and implement the request handler without using that argument at all.</p><p>If most of the time, ignoring the context is fine, then what <em>are</em> contexts?</p><h2 id=what-are-contexts>What are Contexts?</h2><p>The <a href=https://golang.org/pkg/context/><code>context</code></a> package in the Go standard library provides a type <code>Context</code> that contains request-scoped values and signals that are safe for simultaneous use by multiple go routines and which facilitates communication across API boundaries and between processes.</p><p>So what <em>should</em> you do with the context? Here&rsquo;s what the documentation suggests:</p><blockquote><p>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</p></blockquote><p>Two important rules follow from the statement above, which we&rsquo;ll explore more fully in the next few sections of this post. In summary:</p><ol><li>If you implement a long-running computation, you should run it in a go routine and <code>select</code> from either <code>ctx.Done()</code> or the result channel.</li><li>If you call a downstream contextual function, e.g. a database or a follow-on microservice, you should pass it the same context.</li></ol><h2 id=using-contexts-in-long-running-computations>Using Contexts in Long-Running Computations</h2><p>Say you have some work to do that may take a long time. What&rsquo;s a good threshold?</p><p>Frontier API responses need to be returned in a second or less. That means you get approximately:</p><ul><li>500ms for processing</li><li>250ms in either direction for network traffic</li></ul><p>Therefore &ldquo;a long time&rdquo; is likely anything that takes more than 450ms, though your needs may vary.</p><p>As for database requests, as a rule of thumb, responses should take around 20-50ms. If you&rsquo;re composing transactions programatically and not in SQL, this is another estimation point. Different systems will have different response times, so it&rsquo;s a best practice to measure and know for sure.</p><p>In addition, the client is likely going to set some kind of timeout on the request e.g. it will wait 5 seconds before retrying or displaying a message to the user. What happens if the client timeout is exceeded while you&rsquo;re processing? The client is going to stop waiting for a response, but the server will continue handling the request (most likely a wasted effort), <em>unless</em> we can detect the deadline exceeded. This is where the context comes in and is crtical.</p><p>Therefore, we follow Rule #1 as follows:</p><p>If you have a function <code>hardWork</code>, simply move it into a go routine and return the result in a channel:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>asyncHardWork</span>() &lt;-<span style=color:#6ab825;font-weight:700>chan</span> result {
    done := <span style=color:#24909d>make</span>(<span style=color:#6ab825;font-weight:700>chan</span> result, <span style=color:#3677a9>1</span>)

    <span style=color:#6ab825;font-weight:700>go</span> <span style=color:#6ab825;font-weight:700>func</span>(done <span style=color:#6ab825;font-weight:700>chan</span>&lt;- result) {
        done &lt;- <span style=color:#447fcf>hardWork</span>()
    }(done)


    <span style=color:#6ab825;font-weight:700>return</span> done
}
</code></pre></div><p>Then in your service handler, select either from <code>ctx.Done()</code> or the result channel as follows:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>select</span> {
<span style=color:#6ab825;font-weight:700>case</span> &lt;-ctx.<span style=color:#447fcf>Done</span>():
    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>nil</span>, ctx.<span style=color:#447fcf>Err</span>()
<span style=color:#6ab825;font-weight:700>case</span> result := &lt;-<span style=color:#447fcf>asyncHardWork</span>():
    <span style=color:#6ab825;font-weight:700>return</span> result, <span style=color:#6ab825;font-weight:700>nil</span>
}
</code></pre></div><p>In this code, if the client deadline is exceeded, then the error will be returned immediately and the request handler routine will stop. While the <code>asyncHardWork</code> routine will continue until it&rsquo;s finished, any steps after <code>hardWork</code> won&rsquo;t continue, because the request has terminated early. Alternatively, you could create a contextual hard work. For example, if <code>hardWork</code> is iterative, you could check if the context is done on every pass, using a default to ensure the select is non-blocking:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>hardWork</span>(ctx context.Context) (result, <span style=color:#6ab825;font-weight:700>error</span>) {
    <span style=color:#6ab825;font-weight:700>for</span> {
        <span style=color:#999;font-style:italic>// Check to ensure the context isn&#39;t canceled
</span><span style=color:#999;font-style:italic></span>        <span style=color:#6ab825;font-weight:700>select</span> {
        <span style=color:#6ab825;font-weight:700>case</span>: &lt;-ctx.<span style=color:#447fcf>Done</span>():
            <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>nil</span>, ctx.<span style=color:#447fcf>Err</span>()
        <span style=color:#6ab825;font-weight:700>default</span>:
            <span style=color:#999;font-style:italic>// Keep processing the for loop
</span><span style=color:#999;font-style:italic></span>        }

        <span style=color:#999;font-style:italic>// Computation here
</span><span style=color:#999;font-style:italic></span>    }

    <span style=color:#6ab825;font-weight:700>return</span> result
}
</code></pre></div><h2 id=using-contexts-to-share-attention-span-across-microservices>Using Contexts to Share Attention Span Across Microservices</h2><p>This brings us to Rule #2:</p><p>If the downstream function is contextual e.g. accepts a context as the first argument, you should <em>always pass the <strong>same context</strong> to it</em>.</p><p>This may seem a little unnatural. For example, you may want to give a shorter deadline to a database transaction, but you don&rsquo;t know how long the client context is, which may have been passed to you from upstream processing that also took a long time. The key is to rely on the client to specify their context.</p><p>We can see this especially with database transactions:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (s *Server) <span style=color:#447fcf>MyRPC</span>(ctx context.Context in *Request) (out *Reply, err <span style=color:#6ab825;font-weight:700>error</span>) {
    <span style=color:#999;font-style:italic>// Begin a database transaction assuming we have a global variable, conn, that&#39;s a
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// database connection pool -- pass in the same context.
</span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>var</span> tx *sql.Tx
    <span style=color:#6ab825;font-weight:700>if</span> tx, err = conn.<span style=color:#447fcf>BeginTx</span>(ctx, <span style=color:#6ab825;font-weight:700>nil</span>); err != <span style=color:#6ab825;font-weight:700>nil</span> {
        <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>nil</span>, status.<span style=color:#447fcf>Errorf</span>(codes.FailedPrecondition, <span style=color:#ed9d13>&#34;could not start tx: %s&#34;</span>, err)
    }
    <span style=color:#6ab825;font-weight:700>defer</span> tx.<span style=color:#447fcf>Rollback</span>() <span style=color:#999;font-style:italic>// Ignore rollback if tx is committed later in function.
</span><span style=color:#999;font-style:italic></span>
    <span style=color:#999;font-style:italic>// Do transaction work here.
</span><span style=color:#999;font-style:italic></span>}
</code></pre></div><p>If the context is done, then any <code>tx</code> calls (e.g. <code>tx.Query()</code> or <code>tx.Commit()</code>) will return a &ldquo;deadline exceeded&rdquo; error, allowing the transaction to stop processing and be rolled back to ensure that the database state is not left inconsistent.</p><h2 id=microservice-chains-and-context-handling-an-example>Microservice Chains and Context Handling: An Example</h2><p>Let&rsquo;s imagine that we&rsquo;re building a recommender system that takes incoming data from clients, and engages a series of microservices (represented as different terminal windows below) to return a prediction.</p><p><a href=/images/blog/2021-05-02-microservice-context-terminals.png><img src=/images/blog/2021-05-02-microservice-context-terminals.png alt="Microservice Context Terminals"></a></p><p>For instance, the first service (9000) is likely our API server, which might pass data to an authentication microservice (9001) to ensure the client is allowed to access the service. The authenticator then passes the data to a data preprocessor (9002) to properly encode the values, and the result is then passed to the global modeling service (9003) for the preliminary prediction. This prediction is then passed to a personalization microservice (9004), which filters the results, before finally passing them to the metrics logging microservice (9005).</p><p>In this scenario, in order to respond to the client, each of the microservices must in turn perform some work before firing off a message to the next microservice in the loop, and triggering the next phase of work. Once the final message makes it all the way back to the API server, only then can we properly respond to the client:</p><p><a href=/images/blog/2021-05-02-microservice-chain-success.png><img src=/images/blog/2021-05-02-microservice-chain-success.png alt="Microservice Chain Success"></a></p><p>If we engineer our chain of microservices to have independent contexts, they will have no way of sharing information, such as a timeout from the client. In this case, the subsequent microservices in the chain (9003, 9004, and 9005) go on to perform hard work that is no longer needed, since the client is no longer waiting for the response:</p><p><a href=/images/blog/2021-05-02-microservice-chain-timeout.png><img src=/images/blog/2021-05-02-microservice-chain-timeout.png alt="Microservice Chain Timeout"></a></p><p>However, if our chain shares a single context, as soon as the active microservice (9002) identifies the client timeout, it breaks the chain, saving the subsequent services the trouble of performing unneeded hard work:</p><p><a href=/images/blog/2021-05-02-microservice-chain-timeout-with-context.png><img src=/images/blog/2021-05-02-microservice-chain-timeout-with-context.png alt="Microservice Chain Timeout with Shared Context"></a></p><h2 id=the-value-of-shared-context>The Value of Shared Context</h2><p>In summary, the two rules of contexts provide three distinct advantages:</p><p>(1) Contexts are the critical mechanism that allow your server implementations to be better behaved;
(2) Contexts result in less processing time and memory;
(3) Contexts allow your services to be more robust and effective.</p><p>Through this modest experiment, we see the value of <em>shared context</em>, especially as services become more complex and increasingly serve a more geographically dispersed customer base.</p><p>The code for experiment can be found at: <a href=https://github.com/rotationalio/ctxms>github.com/rotationalio/ctxms</a>.</p></div><div class=mt-5></div></div></div></div></section></div><footer id=footer class=section-bg><div class=container><div class="row wow fadeInUp" data-wow-duration=500ms><div class=col-xl-12><div class=social-icon><ul class=list-inline><li class=list-inline-item><a href=https://twitter.com/rotationalio><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a href=https://github.com/rotational.io><i class=ti-github></i></a></li><li class=list-inline-item><a href=https://www.linkedin.com/company/rotational/><i class=ti-linkedin></i></a></li></ul></div><div class="copyright text-center"><a href=https://rotational.io/><img src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a><br><p>Copyright © 2021 Rotational Labs, LLC, All Rights Reserved</p></div></div></div></div></footer><script src=https://rotational.io/plugins/jquery/jquery.min.js></script><script src=https://rotational.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://rotational.io/plugins/slick/slick.min.js></script><script src=https://rotational.io/plugins/shuffle/shuffle.min.js></script><script src=https://rotational.io/plugins/magnific-popup/jquery.magnific-popup.min.js></script><script src=https://rotational.io/plugins/lazy-load/lozad.min.js></script><script src=https://rotational.io/plugins/google-map/map.js></script><script src=https://rotational.io/js/script.min.5db5ae6f88052715e823d7c52f3fa7a832565352b0f76c1d2cee2a3b564a0716fa9d51878a9965389c3d856f2d7c6330.js integrity=sha384-XbWub4gFJxXoI9fFLz+nqDJWU1Kw92wdLO4qO1ZKBxb6nVGHipllOJw9hW8tfGMw></script></body></html>