<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Synchronizing Structs for Safe Concurrency in Go</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Synchronizing Structs for Safe Concurrency in Go"><meta name=author content="Rotational Labs, LLC"><meta name=generator content="Hugo 0.81.0"><link rel=stylesheet href=https://rotational.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://rotational.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://rotational.io/plugins/magnific-popup/magnific-popup.css><link rel=stylesheet href=https://rotational.io/plugins/slick/slick.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento+Sans:400,700&display=swap"><link rel=stylesheet href=https://rotational.io/css/style.min.css media=screen><link rel=stylesheet href=https://rotational.io/css/custom.min.css media=screen><link rel="shortcut icon" href=https://rotational.io/images/favicon.png type=image/x-icon><link rel=icon href=https://rotational.io/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-2FKX6CWJHW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-2FKX6CWJHW')</script></head><body id=body data-spy=scroll data-target=.navbar data-offset=55><div id=content><section class="sticky-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-dark"><a class="navbar-brand p-0" href=/><img class=lozad data-src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a>
<button class="navbar-toggler rounded-0" type=button data-toggle=collapse data-target=#navigation>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://rotational.io/#about>about</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#services>services</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#team>team</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/blog>blog</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#contact>contact</a></li></ul><select id=select-language onchange="location=this.value"><option id=en value=https://rotational.io/blog/synchronizing-structs/ selected>En</option><option id=fr value=https://rotational.io/fr/blog/synchronizing-structs-for-safe-concurrency-in-go/>Fr</option></select></div></nav></div></section><section class=section><div class=container><div class=row><div class="col-lg-8 offset-lg-2 text-center"><h1>Synchronizing Structs for Safe Concurrency in Go</h1><ul class="list-inline mb-50"><li class=list-inline-item><a href=/author/benjamin-bengfort/>Benjamin Bengfort</a></li><li class=list-inline-item>Tuesday, Feb 21, 2017</li></ul><img class="img-fluid mb-50 lozad" data-src=https://rotational.io/images/blog/lake_c.jpg alt=blog-image></div><div class="col-lg-8 offset-lg-2"><div class=post-single-content><p>Go is <a href=https://divan.github.io/posts/go_concurrency_visualize/>built for concurrency</a> by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a <a href=https://blog.golang.org/race-detector>race detector</a>) but developers still need to be aware of the interactions between various threads in their programs.</p><p>In any shared memory system the biggest concern is <a href=https://en.wikipedia.org/wiki/Synchronization_(computer_science)>synchronization</a>: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of <a href=https://gobyexample.com/channels>channels</a>. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a <a href=https://en.wikipedia.org/wiki/Barrier_(computer_science)>barrier</a> since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.</p><p>Channels are made to implement <a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP</a>, but there are other concurrency primitives like <a href=https://en.wikipedia.org/wiki/Lock_(computer_science)>mutexes</a> (locks designed to enforce mutual exclusion concurrency control). In fact, channels use locks behind the scenes to serialize access, and <a href=http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/>you&rsquo;re likely going to have to use other concurrency primitives anyway</a>. I&rsquo;ve encountered this problem, and have started using mutexes in a very specific way, which this post is about.</p><p>Consider an operation that is not <a href=https://en.wikipedia.org/wiki/Commutative_property>commutative</a> or not <a href=https://en.wikipedia.org/wiki/Associative_property>associative</a> (operations that are can be implemented with <a href=https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>CRDTs</a>), for example concatenating data to a buffer. This operation must be synchronized because the original state must be preserved during the operation. A simple explanation of this is the <code>+=</code> which (for the purpose of our discussion) fetches the original value of the variable, performs the operation and stores the result back to the value. If two processes attempt to <code>+=</code> concurrently a <a href=https://en.wikipedia.org/wiki/Race_condition>race condition</a> occurs because whichever process is first to complete will have its answer overridden. In the following example, the final result of the variable will be <code>"hello Bob"</code> or <code>"hello Alice"</code> depending on which process gets there last, an undesirable state (the second operation may have preferred the concatenation to be <code>"hello Bob and Alice"</code> or <code>"hello Alice and Bob"</code>).</p><p><a href=/images/2017-02-21-race-condition.png><img src=/images/blog/2017-02-21-race-condition.png alt="Race Condition"></a></p><p>The solution is to lock the variable whenever the first process accesses it and then release it when it&rsquo;s done, that way the process is guaranteed the state of the variable for the duration of the operation. Here&rsquo;s how I implement this with a <code>struct</code> in Go:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>type</span> Buffer <span style=color:#6ab825;font-weight:700>struct</span> {
    sync.Mutex        <span style=color:#999;font-style:italic>// wraps a synchronization flag
</span><span style=color:#999;font-style:italic></span>    buf        <span style=color:#6ab825;font-weight:700>string</span> <span style=color:#999;font-style:italic>// the string being concatenated to
</span><span style=color:#999;font-style:italic></span>}
</code></pre></div><p>By embedding the <code>sync.Mutex</code> into the struct, it can now be locked and unlocked. Even more powerfully, you can write methods that lock and <code>defer</code> unlock for very easy thread safe synchronization. Here is an example of safe and unsafe concatenation to the buffer:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (b *Buffer) <span style=color:#447fcf>Concat</span>(s <span style=color:#6ab825;font-weight:700>string</span>) {
	b.buf += s
}

<span style=color:#6ab825;font-weight:700>func</span> (b *Buffer) <span style=color:#447fcf>SafeConcat</span>(s <span style=color:#6ab825;font-weight:700>string</span>) {
	b.<span style=color:#447fcf>Lock</span>()
	<span style=color:#6ab825;font-weight:700>defer</span> b.<span style=color:#447fcf>Unlock</span>()
	b.<span style=color:#447fcf>Concat</span>(s)
}
</code></pre></div><p>It is important to note that safety does not mean that you&rsquo;re guaranteed some other arbitrary order of operations when using goroutines. Consider the following concurrent concatenate example that injects some sleep into the concat function (find the <a href=https://gist.github.com/bbengfort/dcd6a1a36a9670562fe8a04cf836ce49>complete code on Gist</a>):</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>var</span> (
	safe   <span style=color:#6ab825;font-weight:700>bool</span>
	start  time.Time
	group  *sync.WaitGroup
	buffer *Buffer
	alphas []<span style=color:#6ab825;font-weight:700>string</span>
)

<span style=color:#6ab825;font-weight:700>func</span> <span style=color:#447fcf>write</span>(idx <span style=color:#6ab825;font-weight:700>int</span>, safe <span style=color:#6ab825;font-weight:700>bool</span>) {
	<span style=color:#6ab825;font-weight:700>defer</span> group.<span style=color:#447fcf>Done</span>()

	<span style=color:#6ab825;font-weight:700>if</span> idx &gt;= <span style=color:#24909d>len</span>(alphas) {
		<span style=color:#6ab825;font-weight:700>return</span>
	}

	<span style=color:#6ab825;font-weight:700>if</span> safe {
		buffer.<span style=color:#447fcf>SafeConcat</span>(alphas[idx])
	} <span style=color:#6ab825;font-weight:700>else</span> {
		buffer.<span style=color:#447fcf>Concat</span>(alphas[idx])
	}

}

group = <span style=color:#24909d>new</span>(sync.WaitGroup)
alphas = []<span style=color:#6ab825;font-weight:700>string</span>{<span style=color:#ed9d13>&#34;a&#34;</span>, <span style=color:#ed9d13>&#34;b&#34;</span>, <span style=color:#ed9d13>&#34;c&#34;</span>, <span style=color:#ed9d13>&#34;d&#34;</span>, <span style=color:#ed9d13>&#34;e&#34;</span>, <span style=color:#ed9d13>&#34;f&#34;</span>, <span style=color:#ed9d13>&#34;g&#34;</span>, <span style=color:#ed9d13>&#34;h&#34;</span>, <span style=color:#ed9d13>&#34;i&#34;</span>,}
buffer = <span style=color:#24909d>new</span>(Buffer)
start = time.<span style=color:#447fcf>Now</span>()

<span style=color:#6ab825;font-weight:700>for</span> i := <span style=color:#3677a9>0</span>; i &lt; <span style=color:#24909d>len</span>(alphas); i++ {
    group.<span style=color:#447fcf>Add</span>(<span style=color:#3677a9>1</span>)
    <span style=color:#6ab825;font-weight:700>go</span> <span style=color:#447fcf>write</span>(i, safe)
}

group.<span style=color:#447fcf>Wait</span>()
fmt.<span style=color:#447fcf>Printf</span>(<span style=color:#ed9d13>&#34;\nresult: %s in %s (safe=%t)\n&#34;</span>, buffer, time.<span style=color:#447fcf>Since</span>(start), safe)
</code></pre></div><p>Here, we&rsquo;re using a <code>sync.WaitGroup</code> to determine when all the go routines are complete (e.g. join on the collection of routines) and have them write the letter of their index to the buffer. The output is as follows:</p><pre><code>result: fiedhcjgab in 1.004835942s (safe=false)
result: kbahgifjced in 11.020241668s (safe=true)
</code></pre><p>Note that in the unsafe case, one of the letters is missing because of incorrect synchronization and that the safe case took 11 seconds to complete. This is because each goroutine had to wait (for a second) until it could access the buffer since it was locked. However, it&rsquo;s also important to note that neither method (safe or unsafe) produced <code>"abcdefghijk"</code>, since the locking order is about which routine got to the lock first, not about what order the goroutine was started.</p><p>And honestly, that&rsquo;s the prime lesson from this post (most of which are my notes from implementing this in a production system).</p><p>But of course, I have another question - given the sequential case, how much overhead do the locks add? So benchmarking &mldr;</p><pre><code>BenchmarkUnsafeConcat-8   	 1000000	     47287 ns/op
BenchmarkSafeConcat-8     	 1000000	     53170 ns/op
</code></pre><p>Clearly having locks adds some overhead and if you&rsquo;re not going to do any concurrent programming, then the 6 microseconds it takes to lock and unlock is probably not worth it. On the other hand, if there is the chance that you&rsquo;ll have any concurrency at all - using the <code>sync.Mutex</code> embedding is a very clear and understandable way to go about things.</p></div><div class=mt-5></div></div></div></div></section></div><footer id=footer class=section-bg><div class=container><div class="row wow fadeInUp" data-wow-duration=500ms><div class=col-xl-12><div class=social-icon><ul class=list-inline><li class=list-inline-item><a href=https://twitter.com/rotationalio><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a href=https://github.com/rotational.io><i class=ti-github></i></a></li><li class=list-inline-item><a href=https://www.linkedin.com/company/71689585/admin/><i class=ti-linkedin></i></a></li></ul></div><div class="copyright text-center"><a href=https://rotational.io/><img src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a><br><p>Copyright Â© 2021 Rotational Labs, LLC, All Rights Reserved</p></div></div></div></div></footer><script src=https://rotational.io/plugins/jquery/jquery.min.js></script><script src=https://rotational.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://rotational.io/plugins/slick/slick.min.js></script><script src=https://rotational.io/plugins/shuffle/shuffle.min.js></script><script src=https://rotational.io/plugins/magnific-popup/jquery.magnific-popup.min.js></script><script src=https://rotational.io/plugins/lazy-load/lozad.min.js></script><script src=https://rotational.io/plugins/google-map/map.js></script><script src=https://rotational.io/js/script.min.5db5ae6f88052715e823d7c52f3fa7a832565352b0f76c1d2cee2a3b564a0716fa9d51878a9965389c3d856f2d7c6330.js integrity=sha384-XbWub4gFJxXoI9fFLz+nqDJWU1Kw92wdLO4qO1ZKBxb6nVGHipllOJw9hW8tfGMw></script></body></html>