[
    {
        "uri": "/_index",
        "content": "---\ndate: 2023-06-07T12:01:28-04:00\ntitle: \"Data Playground\"\nheadertext: \"Data Playground\"\nsubheadertext: \"Streaming data sources and examples for your apps, models, and services\"\nnoicon: true\ntype: \"data-playground\"\nissearchenabled: true\nisfilterenabled: true\n---",
        "tags": []
    },
    {
        "uri": "/dc-metro",
        "content": "---\ntitle: \"DC Metro\"\nslug: \"dc-metro\"\nsubtitle: \"Public Transport Data\"\ndraft: false\nimage: img/data-playground/dc-metro.png\nsummary: Connect to DC Metro public transport data and start experimenting with scheduling models and apps.\ngithub_link: https://github.com/rotationalio/data-playground/tree/main/wmata\ndescription: DC WMATA provides public transportation data such as real-time bus and rail predictions.\nproducer_name: Washington Metro Area Transit Authority (WMATA)\nproducer_link: https://developer.wmata.com/\ndata: Bus & train trip updates, alerts, and vehicle positions.\nisaccountrequired: true\nlicense: Free\nlicense_warning: Please review terms and conditions. Access to data sources can change.\nisapikey_required: true\napi_type: JSON, GTFS protocol buffers\nsdks: N/A\nlimits: The default tier (free) is rate-limited to 10 calls/second and 50,000 calls per day.\nweight: 5\n---\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\n\n\"\"\"\nNote: this assumes you also have a MetroPublisher ;)\nFeel free to use the publisher here:\nhttps://github.com/rotationalio/data-playground/tree/main/wmata/python\n\"\"\"\nimport json\nimport asyncio\nimport warnings\n\nfrom pyensign.ensign import Ensign\nfrom pyensign.api.v1beta1.ensign_pb2 import Nack\n\nTODO Python3.10 needs to ignore DeprecationWarning: There is no current event loop\nwarnings.filterwarnings(\"ignore\")\n\nclass MetroSubscriber:\n    \"\"\"\n    MetroSubscriber subscribes to an Ensign stream that the MetroPublisher is\n    writing new metro reports to at some regular interval.\n    \"\"\"\n\n    def init(self, topic=\"metro-updates-json\"):\n        \"\"\"\n        Initialize the MetroSubscriber, which will allow a data consumer to\n        subscribe to the topic that the publisher is writing metro updates to\n\n        Parameters\n        ----------\n        topic : string, default: \"metro-updates-json\"\n            The name of the topic you wish to subscribe to.\n        \"\"\"\n        self.topic = topic\n        self.ensign = Ensign()\n\n    def run(self):\n        \"\"\"\n        Run the subscriber forever.\n        \"\"\"\n        asyncio.geteventloop().rununtilcomplete(self.subscribe())\n\n    async def handle_event(self, event):\n        \"\"\"\n        Decode and ack the event.\n        \"\"\"\n        try:\n            data = json.loads(event.data)\n        except json.JSONDecodeError:\n            print(\"Received invalid JSON in event payload:\", event.data)\n            await event.nack(Nack.Code.UNKNOWN_TYPE)\n            return\n\n        print(\"New metro report received:\", data)\n        await event.ack()\n\n    async def subscribe(self):\n        \"\"\"\n        Subscribe to the metro topic and parse the events.\n        \"\"\"\n        id = await self.ensign.topic_id(self.topic)\n        await self.ensign.subscribe(id, onevent=self.handleevent)\n        await asyncio.Future()\n\nif name == \"main\":\n    subscriber = MetroSubscriber()\n    subscriber.run()\n\n{{% /data-playground-code-tab %}}\n\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Code snippet coming soon!\")\n}\n\n{{% /data-playground-code-tab %}}\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{% coming-soon %}}\n\nComing soon!\n\n{{% /coming-soon %}}",
        "tags": []
    },
    {
        "uri": "/finnhub",
        "content": "---\ntitle: \"Finnhub\"\nslug: \"finnhub\"\nsubtitle: \"Stock Market Data\"\ndraft: false\nimage: img/data-playground/finnhub.png\ngithub_link: https://github.com/rotationalio/data-playground/tree/main/finnhub\ndescription: FinnHub provides real-time stock market data. Note that the stock market is closed during certain times of days and days of the week.\nsummary: Finnhub provides real-time RESTful APIs and WebSocket for stocks, currencies, and crypto.\nlicense: Free, Commercial\nlicense_warning: Please review terms and conditions. Access to data sources can change.\nproducer_name: FinnHub\nproducer_link: https://finnhub.io/\nisapikey_required: true\napi_type: REST, WebSocket\nsdks: Python, Go\nlimits: \"60 API calls/minute for the free tier. Other pricing plans available.\"\ndata: Stock prices, company profiles, company & market news\nisaccountrequired: true\nweight: 1\n---\n\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\nimport os\nimport sys\nimport json\nimport asyncio\nfrom datetime import datetime\n\nimport websockets\nfrom pyensign.events import Event\nfrom pyensign.ensign import Ensign\n\nasync def handle_ack(ack):\n    ts = datetime.fromtimestamp(ack.committed.seconds + ack.committed.nanos / 1e9)\n    print(f\"Event committed at {ts}\")\n\nasync def handle_nack(nack):\n    print(f\"Could not commit event {nack.id} with error {nack.code}: {nack.error}\")\n\nclass TradesPublisher:\n    \"\"\"\n    TradesPublisher queries an API for trading updates and publishes events to Ensign.\n    \"\"\"\n    def init(self, symbols=[\"AAPL\", \"MSFT\", \"AMZN\"], topic=\"trades\"):\n        self.symbols = symbols\n        self.topic = topic\n        self.ensign = Ensign()\n\n    def run(self):\n        \"\"\"\n        Run the publisher forever.\n        \"\"\"\n\n        # Load finnhub API key from environment variable.\n        token = os.environ.get(\"FINNHUBAPIKEY\")\n        if token is None:\n            raise ValueError(\"FINNHUBAPIKEY environment variable not set.\")\n\n        # Run the publisher.\n        asyncio.geteventloop().rununtilcomplete(self.recvandpublish(f\"wss://ws.finnhub.io?token={token}\"))\n\n    async def recvandpublish(self, uri):\n        \"\"\"\n        Receive messages from the websocket and publish events to Ensign.\n        \"\"\"\n\n        # Ensure that the Ensign topic exists before publishing.\n        if not await self.ensign.topic_exists(self.topic):\n            await self.ensign.create_topic(self.topic)\n\n        while True:\n            try:\n                async with websockets.connect(uri) as websocket:\n                    for symbol in self.symbols:\n                        await websocket.send(f'{{\"type\":\"subscribe\",\"symbol\":\"{symbol}\"}}')\n\n                    while True:\n                        message = await websocket.recv()\n                        for event in self.messagetoevents(json.loads(message)):\n                            await self.ensign.publish(self.topic, event, ackcallback=handleack, nackcallback=handlenack)\n            except websockets.exceptions.ConnectionClosedError as e:\n                # TODO: Make sure reconnect is happening for dropped connections.\n                print(f\"Websocket connection closed: {e}\")\n                await asyncio.sleep(1)\n\n    def messagetoevents(self, message):\n        \"\"\"\n        Convert a message from the Finnhub API to multiple Ensign events.\n        \"\"\"\n\n        message_type = message[\"type\"]\n        if message_type == \"ping\":\n            return\n        elif message_type == \"trade\":\n            for trade in message[\"data\"]:\n                data = {\n                    \"price\": trade[\"p\"],\n                    \"symbol\": trade[\"s\"],\n                    \"timestamp\": trade[\"t\"],\n                    \"volume\": trade[\"v\"]\n                }\n                yield Event(json.dumps(data).encode(\"utf-8\"), mimetype=\"application/json\")\n        else:\n            raise ValueError(f\"Unknown message type: {message_type}\")\n{{% /data-playground-code-tab %}}\n\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\tensign \"github.com/rotationalio/go-ensign\"\n\tapi \"github.com/rotationalio/go-ensign/api/v1beta1\"\n\tmimetype \"github.com/rotationalio/go-ensign/mimetype/v1beta1\"\n)\n\n// This is the nickname of the topic, it will get mapped to an ID that actually gets used by Ensign\nconst Trades = \"trades\"\n\n// This represents the structure of an individual stock data point that comes back from the Finnhub API\ntype Data struct {\n\tSymbol     string   json:\"s\"\n\tPrice      float64  json:\"p\"\n\tTimestamp  uint64   json:\"t\"\n\tConditions []string json:\"c\" omitempty:\"true\"\n}\n\n// This represents the entire websocket response that comes back from a single call to the Finnhub Server\n// Note that a single Response may contain many Data points\ntype Response struct {\n\tType string json:\"type\"\n\tData []Data json:\"data\"\n}\n\n// Announce is a helper function that takes as input a event chan that gets created by calling sub.Subscribe()\n// and ranges over any events that it receives on the chan, unmarshals them, and prints them out\nfunc Announce(events <-chan *ensign.Event) {\n\tfor tick := range events {\n\t\ttrades := &Response{}\n\t\tif err := json.Unmarshal(tick.Data, &trades); err != nil {\n\t\t\tpanic(\"unable to unmarshal event: \" + err.Error())\n\t\t}\n\t\tfmt.Println(trades)\n\t}\n}\n\nfunc main() {\n\n\t// Create Ensign Client\n\tclient, err := ensign.New() // if your credentials are already in your bash profile, you don't have to pass anything into New()\n\t// client, err := ensign.New(ensign.WithCredentials(\"YOUR CLIENT ID HERE!\", \"YOUR CLIENT SECRET HERE!\"))\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"could not create client: %s\", err))\n\t}\n\n\t// Check to see if topic exists, if it does then the variable exists will be True\n\texists, err := client.TopicExists(context.Background(), Trades)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"unable to check topic existence: %s\", err))\n\t}\n\n\tvar topicID string\n\t// If the topic does not exist, create it using the CreateTopic method\n\tif !exists {\n\t\tif topicID, err = client.CreateTopic(context.Background(), Trades); err != nil {\n\t\t\tpanic(fmt.Errorf(\"unable to create topic: %s\", err))\n\t\t}\n\t} else {\n\t\t// The topic does exist, but we need to figure out what the Topic ID is, so we need\n\t\t// to query the ListTopics method to get back a list of all the topic nickname : topicID mappings\n\t\tif topicID, err = client.TopicID(context.Background(), Trades); err != nil {\n\t\t\tpanic(fmt.Errorf(\"unable to get id for topic: %s\", err))\n\t\t}\n\n\t}\n\n\tkey := os.Getenv(\"FINNHUB_KEY\")\n\tif key == \"\" {\n\t\tpanic(\"Finnhub key is required: get one at https://finnhub.io/\")\n\t}\n\n\t// Get trades from Finnhub - FYI this Dialer dials the \"Trades\" endpoint\n\t// see https://finnhub.io/docs/api/websocket-trades for more details\n\tfinnhub_url := fmt.Sprint(\"wss://ws.finnhub.io?token=\", key)\n\tw, , err := websocket.DefaultDialer.Dial(finnhuburl, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer w.Close()\n\n\t// The complete list of options is long! This is a short list, but no guarantee that all will be updated for every tick\n\tsymbols := []string{\"AAPL\", \"AMZN\", \"PCG\", \"SNAP\"}\n\tfor _, s := range symbols {\n\t\tmsg, _ := json.Marshal(map[string]interface{}{\"type\": \"subscribe\", \"symbol\": s})\n\t\tw.WriteMessage(websocket.TextMessage, msg)\n\t}\n\n\t// Create a subscriber  - the same subscriber should be consuming each event that comes down the pipe\n\tsub, err := client.Subscribe(topicID)\n\tif err != nil {\n\t\tfmt.Printf(\"could not create subscriber: %s\", err)\n\t}\n\n\t// Loop over each response that is returned by the Finnhub websocket, publish it to the topicID, have the subscriber consume to the events channel\n\tfor {\n\t\t// The Response struct is how we will boost the standard json marshalling library to know how to unpack and repackage Finnhub ticks\n\t\tmsg := &Response{}\n\t\terr := w.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(\"Message from the websocket server is \", msg)\n\n\t\te := &ensign.Event{\n\t\t\tMimetype: mimetype.ApplicationJSON,\n\t\t\tType: &api.Type{\n\t\t\t\tName:         \"Generic\",\n\t\t\t\tMajorVersion: 1,\n\t\t\t\tMinorVersion: 0,\n\t\t\t\tPatchVersion: 0,\n\t\t\t},\n\t\t}\n\n\t\tif e.Data, err = json.Marshal(msg); err != nil {\n\t\t\tpanic(\"could not marshal data to JSON: \" + err.Error())\n\t\t}\n\n\t\t// Publish the newly received tick event to the Topic\n\t\tfmt.Printf(\"Publishing to topic id: %s\\n\", topicID)\n\t\ttime.Sleep(1 * time.Second)\n\t\tclient.Publish(topicID, e)\n\n\t\t// Goroutine to check the events channel to ensure that subscriber is getting all the ticks!\n\t\ttime.Sleep(1 * time.Second)\n\t\tgo Announce(sub.C)\n\t}\n}\n{{% /data-playground-code-tab %}}\n\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{ data-playground-showcase }}",
        "tags": []
    },
    {
        "uri": "/noaa",
        "content": "---\ntitle: \"NOAA\"\nslug: \"noaa\"\nsubtitle: \"Weather Data\"\ndraft: false\nimage: img/data-playground/noaa.png\ngithub_link: https://github.com/rotationalio/data-playground/tree/main/weather\ndescription: The National Oceanic and Atmospheric Administration's (NOAA's) National Weather Service offers critical real-time data. Get forecasts, alerts, observations, and other weather data.\nsummary: The National Weather Service (NWS) API allows access to critical forecasts, alerts, observations, and other weather data.\nlicense: Free\nlicense_warning: Please review terms and conditions. Access to data sources can change.\nproducer_name: NOAA\nproducer_link: https://www.weather.gov/documentation/services-web-api\nisapikey_required: false\napi_type: REST, JSON-LD, GeoJSON, OXML\nsdks: N/A\nlimits: The rate limit is not public information, but allows a generous amount for typical use. If the rate limit is exceeded, the request will return with an error, and may be retried after the limit clears (typically within 5 seconds). Proxies are more likely to reach the limit, whereas requests directly from clients are not likely.\ndata: Weather forecasts, alerts, and observations\nisaccountrequired: false\nweight: 2\n---\n\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\n\nimport json\nimport asyncio\nimport warnings\nfrom datetime import datetime\n\nimport requests\nfrom pyensign.events import Event\nfrom pyensign.ensign import Ensign\n\nTODO Python3.10 needs to ignore DeprecationWarning: There is no current event loop\nwarnings.filterwarnings(\"ignore\")\n\n TODO: replace with YOU - your email and app details :)\nME = \"(https://rotational.io/data-playground/noaa/, weather@rotational.io)\"\n\nTODO: these are memorable for ME. Replace with the locations of interest to YOU\nLOCS = {\n    \"north_pole\": {\n        \"lat\": \"64.7511\",\n        \"long\": \"-147.3494\"\n    },\n    \"cafedumonde\": {\n        \"lat\": \"29.957684\",\n        \"long\": \"-90.061892\"\n    },\n}\n\nclass WeatherPublisher:\n    \"\"\"\n    WeatherPublisher queries an API for weather updates and publishes events to Ensign.\n    \"\"\"\n    def init(self, topic=\"noaa-reports-json\", interval=60, locations=LOCS, user=ME):\n        \"\"\"\n        Initialize a WeatherPublisher by specifying a topic, locations, and other user-\n        defined parameters.\n\n        Parameters\n        ----------\n        topic : string, default: \"noaa-reports-json\"\n            The name of the topic you wish to publish to. If the topic doesn't yet\n            exist, Ensign will create it for you. Tips on topic naming conventions can\n            be found at https://ensign.rotational.dev/getting-started/topics/\n\n        interval : int, default: 60\n            The number of seconds to wait between API calls so that you do not anger\n            the weather API gods\n\n        locations : dict\n            A dictionary expressing the locations to retrieve weather details for.\n            Note that these should all be in the USA since NOAA is located in the US :)\n\n        user : str\n            When querying the NOAA API, as a courtesy, they like you to identify your\n            app and contact info (aka User Agent details)\n        \"\"\"\n        self.topic = topic\n        self.interval = interval\n        self.locations = locations\n        self.url = \"https://api.weather.gov/points/\"\n        self.user = {\"User-Agent\": user}\n        self.datatype = \"application/json\"\n\n         NOTE: If you need a clientid and clientsecret, register for a free account\n        # at: https://rotational.app/register\n\n        # Start a connection to the Ensign server. If you do not supply connection\n        # details, PyEnsign will read them from your environment variables.\n        self.ensign = Ensign()\n\n        # Alternatively you can supply clientid & clientsecret as string args, eg\n        # self.ensign = Ensign(clientid=\"yourclientid\", clientsecret=\"your_secret\")\n\n    async def print_ack(self, ack):\n        \"\"\"\n        Enable the Ensign server to notify the Publisher the event has been acknowledged\n\n        This is optional for you, but can be very helpful for communication in\n        asynchronous contexts!\n        \"\"\"\n        ts = datetime.fromtimestamp(\n            ack.committed.seconds + ack.committed.nanos / 1e9)\n        print(f\"Event committed at {ts}\")\n\n    async def print_nack(self, nack):\n        \"\"\"\n        Enable the Ensign server to notify the Publisher the event has NOT been\n        acknowledged\n\n        This is optional for you, but can be very helpful for communication in\n        asynchronous contexts!\n        \"\"\"\n        print(f\"Event was not committed with error {nack.code}: {nack.error}\")\n\n    def compose_query(self, location):\n        \"\"\"\n        Combine the base URI with the lat/long query params\n\n        Parameters\n        ----------\n        location : dict\n            A dictionary expressing a location to retrieve weather details for.\n            Note that it should all be in the USA since NOAA is located in the US :)\n            For example: {\"lat\": \"64.7511\", \"long\": \"-147.3494\"}\n        \"\"\"\n        lat = location.get(\"lat\", None)\n        long = location.get(\"long\", None)\n        if lat is None or long is None:\n            raise Exception(\"unable to parse latitude/longitude from location\")\n\n        return self.url + lat + \",\" + long\n\n    def run(self):\n        \"\"\"\n        Run the publisher forever.\n        \"\"\"\n        asyncio.geteventloop().rununtilcomplete(self.recvandpublish())\n\n    async def recvandpublish(self):\n        \"\"\"\n        At some interval (self.interval), ping the api.weather.com to get\n        weather reports for the self.locations.\n\n        NOTE: this requires 2 calls to the NOAA API, per location:\n            the first request provides a lat/long and retrieves forecast URL\n            the second request provides the forecast URL and gets forecast details\n\n        Publish report data to the self.topic\n        \"\"\"\n        await self.ensign.ensuretopicexists(self.topic)\n\n        while True:\n            for location in self.locations.values():\n                # Note that we're making a different API call for each location\n                # TODO: can these be bundled so that we can make fewer calls?\n                query = self.compose_query(location)\n\n                # If successful, the initial response returns a link you can use to\n                # retrieve the full hourly forecast\n                response = requests.get(query).json()\n                forecasturl = self.parseforecast_link(response)\n                forecast = requests.get(forecast_url).json()\n\n                # After we retrieve and unpack the full hourly forecast, we can publish\n                # each period of the forecast as a new event\n                events = self.unpacknoaaresponse(forecast)\n                for event in events:\n                    await self.ensign.publish(\n                        self.topic,\n                        event,\n                        onack=self.printack,\n                        onnack=self.printnack,\n                    )\n            await asyncio.sleep(self.interval)\n\n    def parseforecastlink(self, message):\n        \"\"\"\n        Parse a preliminary forecast response from the NOAA API to get a forecast URL\n\n        Parameters\n        ----------\n        message : dict\n            JSON formatted response from the NOAA API containing a forecast URL\n\n        Returns\n        -------\n        forecast_link : string\n            Specific API-generated URL with the link to get the detailed forecast for\n            the requested location\n        \"\"\"\n        properties = message.get(\"properties\", None)\n        if properties is None:\n            raise Exception(\"unexpected response from api call, no properties\")\n\n        forecast_link = properties.get(\"forecast\", None)\n        if forecast_link is None:\n            raise Exception(\"unexpected response from api call, no forecast\")\n\n        return forecast_link\n\n    def unpacknoaaresponse(self, message):\n        \"\"\"\n        Convert a message from the NOAA API to potentially multiple Ensign events,\n        and yield each.\n\n        Parameters\n        ----------\n        message : dict\n            JSON formatted response from the NOAA API containing forecast details\n        \"\"\"\n        properties = message.get(\"properties\", None)\n        if properties is None:\n            raise Exception(\"unexpected response from forecast request, no properties\")\n\n        periods = properties.get(\"periods\", None)\n        if periods is None:\n            raise Exception(\"unexpected response from forecast request, no periods\")\n\n        for period in periods:\n            # There's a lot available! For this example, we'll just parse out a few\n            # fields from the NOAA API response:\n            data = {\n                \"name\": period.get(\"name\", None),\n                \"summary\": period.get(\"shortForecast\", None),\n                \"temperature\": period.get(\"temperature\", None),\n                \"units\": period.get(\"temperatureUnit\", None),\n                \"daytime\": period.get(\"isDaytime\", None),\n                \"start\": period.get(\"startTime\", None),\n                \"end\": period.get(\"endTime\", None),\n            }\n\n            yield Event(json.dumps(data).encode(\"utf-8\"), mimetype=self.datatype)\n\nif name == \"main\":\n    publisher = WeatherPublisher()\n    publisher.run()\n\n{{% /data-playground-code-tab %}}\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog/log\"\n)\n\n// NOTE: A User Agent is required to identify your application.\n// This string can be anything, and should be unique to your application\n// Include contact information (website or email) so NOAA can contact you\n// if your string is associated to a security event.\nconst (\n\tUserAgent      = \"(myweatherapp.com, contact@myweatherapp.com)\"\n\tBaseWeatherURL = \"https://api.weather.gov\"\n)\n\ntype Weather struct {\n\tclient  *http.Client\n\tbaseURL *url.URL\n}\n\nfunc NewWeatherAPI() (api *Weather, err error) {\n\tapi = &Weather{\n\t\tclient: &http.Client{\n\t\t\tTransport:     nil,\n\t\t\tCheckRedirect: nil,\n\t\t\tTimeout:       30 * time.Second,\n\t\t},\n\t}\n\n\tif api.client.Jar, err = cookiejar.New(nil); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not create cookiejar: %w\", err)\n\t}\n\n\tif api.baseURL, err = url.Parse(BaseWeatherURL); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn api, nil\n}\n\nfunc (s *Weather) Alerts(ctx context.Context) (_ []interface{}, err error) {\n\tvar req *http.Request\n\tif req, err = s.NewRequest(ctx, http.MethodGet, \"/alerts/active\", nil, nil); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rep *http.Response\n\talerts := make(map[string]interface{})\n\tif rep, err = s.Do(req, &alerts, true); err != nil {\n\t\tlogctx := log.With().Err(err).Logger()\n\t\tif rep != nil {\n\t\t\t// Get the NOAA request headers to log the error\n\t\t\tcorrelationID := rep.Header.Get(\"X-Correlation-Id\")\n\t\t\trequestID := rep.Header.Get(\"X-Request-Id\")\n\t\t\tserverID := rep.Header.Get(\"X-Server-Id\")\n\n\t\t\tlogctx = logctx.With().\n\t\t\t\tStr(\"correlation_id\", correlationID).\n\t\t\t\tStr(\"request_id\", requestID).\n\t\t\t\tStr(\"server_id\", serverID).\n\t\t\t\tLogger()\n\t\t}\n\t\tlogctx.Error().Msg(\"could not fetch active alerts\")\n\t\treturn nil, err\n\t}\n\n\tif features, ok := alerts[\"features\"]; ok {\n\t\treturn features.([]interface{}), nil\n\t}\n\treturn nil, fmt.Errorf(\"no alerts returned\")\n}\n\nconst (\n\taccept      = \"application/geo+json\"\n\tacceptLang  = \"en-US,en\"\n\tcontentType = \"application/json; charset=utf-8\"\n)\n\nfunc (s *Weather) NewRequest(ctx context.Context, method, path string, data interface{}, params *url.Values) (req *http.Request, err error) {\n\t// Resolve the URL reference from the path\n\turl := s.baseURL.ResolveReference(&url.URL{Path: path})\n\tif params != nil && len(*params)  0 {\n\t\turl.RawQuery = params.Encode()\n\t}\n\n\tvar body io.ReadWriter\n\tswitch {\n\tcase data == nil:\n\t\tbody = nil\n\tdefault:\n\t\tbody = &bytes.Buffer{}\n\t\tif err = json.NewEncoder(body).Encode(data); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not serialize request data as json: %s\", err)\n\t\t}\n\t}\n\n\t// Create the http request\n\tif req, err = http.NewRequestWithContext(ctx, method, url.String(), body); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not create request: %s\", err)\n\t}\n\n\t// Set the headers on the request\n\treq.Header.Add(\"User-Agent\", UserAgent)\n\treq.Header.Add(\"Accept\", accept)\n\treq.Header.Add(\"Accept-Language\", acceptLang)\n\n\tif body != nil {\n\t\treq.Header.Add(\"Content-Type\", contentType)\n\t}\n\n\t// Add CSRF protection if its available\n\tif s.client.Jar != nil {\n\t\tcookies := s.client.Jar.Cookies(url)\n\t\tfor _, cookie := range cookies {\n\t\t\tif cookie.Name == \"csrf_token\" {\n\t\t\t\treq.Header.Add(\"X-CSRF-TOKEN\", cookie.Value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn req, nil\n}\n\n// Do executes an http request against the server, performs error checking, and\n// deserializes the response data into the specified struct.\nfunc (s *Weather) Do(req *http.Request, data interface{}, checkStatus bool) (rep *http.Response, err error) {\n\tif rep, err = s.client.Do(req); err != nil {\n\t\treturn rep, fmt.Errorf(\"could not execute request: %s\", err)\n\t}\n\tdefer rep.Body.Close()\n\n\t// Detect http status errors if they've occurred\n\tif checkStatus {\n\t\tif rep.StatusCode  200 || rep.StatusCode = 300 {\n\t\t\treturn rep, fmt.Errorf(\"[%d] %s\", rep.StatusCode, rep.Status)\n\t\t}\n\t}\n\n\t// Deserialize the JSON data from the body\n\tif data != nil && rep.StatusCode = 200 && rep.StatusCode < 300 && rep.StatusCode != http.StatusNoContent {\n\t\t// Check the content type to ensure data deserialization is possible\n\t\tif ct := rep.Header.Get(\"Content-Type\"); ct != accept {\n\t\t\treturn rep, fmt.Errorf(\"unexpected content type: %q\", ct)\n\t\t}\n\n\t\tif err = json.NewDecoder(rep.Body).Decode(data); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not deserialize response data: %s\", err)\n\t\t}\n\t}\n\n\treturn rep, nil\n}\n\nfunc (s *Weather) SetBaseURL(u *url.URL) {\n\ts.baseURL = u\n}\n\n{{% /data-playground-code-tab %}}\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{% coming-soon %}}\n\nComing soon!\n\n{{% /coming-soon %}}\n\n",
        "tags": []
    },
    {
        "uri": "/opensky",
        "content": "---\ntitle: \"Opensky\"\nslug: \"opensky\"\nsubtitle: \"Flight Data\"\ndraft: false\nimage: img/data-playground/opensky.png\ngithub_link: https://github.com/rotationalio/data-playground/tree/main/opensky\ndescription: OpenSky provides flight data by aircraft along with arrivals and departures by airport.\nsummary: Connect to flight data and start experimenting with aviation models and apps.\nlicense: Free\nproducer_name: OpenSky\nproducer_link: https://openskynetwork.github.io/opensky-api/\nisapikey_required: false\napi_type: REST\nsdks: Python API, Java API\nlimits: 400 API credits per day and 4,000 API credits per day for OpenSky users\ndata: Flight data, arrivals, departures, aircraft trajectory\nisaccountrequired: false\nweight: 6\n---\n\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\n\ndef example():\n    print(\"Code snippet coming soon!\")\n\n{{% /data-playground-code-tab %}}\n\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Code snippet coming soon!\")\n}\n\n{{% /data-playground-code-tab %}}\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{% coming-soon %}}\n\nComing soon!\n\n{{% /coming-soon %}}\n\n",
        "tags": []
    },
    {
        "uri": "/steam",
        "content": "---\ntitle: \"Steam\"\nslug: \"steam\"\nsubtitle: \"Game Reviews\"\ndraft: false\nimage: img/data-playground/steam.png\ngithub_link: \"https://github.com/rotationalio/data-playground/tree/main/steam\"\ndescription: The Steam API allows users to fetch statistics for individual games, data about users, or news feeds for game updates. All of this can be brought to bear to create powerful analytics on top of video game data made seamless using Ensign.\nsummary: Connect to game review data and start experimenting with game review models and apps.\nlicense: Free\nlicense_warning: Please review terms and conditions. Access to data sources can change.\nproducer_name: Steam\nproducer_link: https://steam.io/\nisapikey_required: true\napi_type: REST\nsdks: N/A\nlimits: 100,000 API calls per day\ndata: Game data and player stats\nisaccountrequired: false\nweight: 3\n---\n\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype SteamApps struct {\n\tAppList struct {\n\t\tApps []SteamApp\n\t}\n}\n\ntype SteamApp struct {\n\tAppId uint64\n\tName  string\n}\n\ntype AppReviews struct {\n\tSuccess      int\n\tQuerySummary QuerySummary\n\tReviews      []Review\n}\n\ntype QuerySummary struct {\n\tNumberReviews          int\n\tReviewScore            int\n\tReviewScoreDescription string\n\tTotalPositive          int\n\tTotalNegative          int\n\tTotalReviews           int\n}\n\ntype Review struct {\n\tID                string\n\tAuthor            Author\n\tLanguage          string\n\tReview            string\n\tTimeCreated       int64\n\tTimeUpdated       int64\n\tVotedUp           bool\n\tVotesUp           int\n\tVotesDown         int\n\tVotesFunny        int\n\tWeightedVoteScore string\n\tCommentCount      json.RawMessage\n\tSteamPurchase     bool\n\tReceivedForFree   bool\n\tEarlyAccess       bool\n}\n\ntype Author struct {\n\tUserID               string\n\tNumberGamesOwned     int\n\tNumberReviews        int\n\tPlayTimeForever      int\n\tPlaytimeLastTwoWeeks int\n\tLastPlayed           int64\n}\n\nfunc main() {\n\tvar err error\n\tvar response *http.Response\n\tif response, err = http.Get(\"https://api.steampowered.com/ISteamApps/GetAppList/v2/\"); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer response.Body.Close()\n\n\tvar apps SteamApps\n\tif response.StatusCode != 200 {\n\t\tfmt.Println(\"status code\", response.StatusCode)\n\t\treturn\n\t}\n\tjson.NewDecoder(response.Body).Decode(&apps)\n\n\tvar reviews AppReviews\n\turl := \"https://store.steampowered.com/appreviews/413150?json=1'\"\n\tif response, err = http.Get(url); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tjson.NewDecoder(response.Body).Decode(&reviews)\n\n\tfmt.Println(len(reviews.Reviews))\n\tfmt.Println(reviews.Reviews[0].Review)\n}\n\n{{% /data-playground-code-tab %}}\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\n\ndef example():\n      print(\"Code snippet coming soon!\")\n\n{{% /data-playground-code-tab %}}\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{% coming-soon %}}\n\nComing soon!\n\n{{% /coming-soon %}}\n",
        "tags": []
    },
    {
        "uri": "/us-geological",
        "content": "---\ntitle: \"Natural Disasters\"\nslug: \"us-geological\"\nsubtitle: \"Earthquake Alerts\"\ndraft: false\nimage: img/data-playground/us-geological.png\ngithub_link: \"https://github.com/rotationalio/data-playground/tree/main/earthquakes\"\ndescription: The U.S. Geological Survey provides the latest alerts as well as detailed information about earthquakes and their impacts.\nsummary: Connect to earthquake data and start experimenting with geological models and apps.\nlicense: Free\nlicense_warning: Please review terms and conditions. Access to data sources can change.\nproducer_name: The U.S. Geological Survey\nproducer_link: \"https://earthquake.usgs.gov/fdsnws/event/1/\"\nisapikey_required: false\napi_type: REST\nsdks: N/A\nlimits: None\ndata: Earthquake data, with magnitudes, locations, and more\nisaccountrequired: false\nweight: 4\n---\n\n{{% data-playground-wrapper %}}\n\n{{% data-playground-code-tabs %}}\n{{% data-playground-code-tab tabIndex=\"python\" name=\"Python\"  %}}\n\nimport json\nimport asyncio\nimport warnings\nfrom datetime import datetime, timedelta\n\nimport requests\nfrom pyensign.events import Event\nfrom pyensign.ensign import Ensign\n\nTODO Python3.10 needs to ignore DeprecationWarning: There is no current event loop\nwarnings.filterwarnings(\"ignore\")\n\n TODO: replace with YOU - your email and app details :)\nME = \"(https://rotational.io/data-playground/us-geological, earthquakes@rotational.io)\"\n\nclass EarthquakePublisher:\n    \"\"\"\n    EarthquakePublisher queries the USGS API for natural disaster updates and publishes them\n    as events to Ensign.\n    \"\"\"\n    def init(self, topic=\"earthquakes-json\", interval=900, user=ME):\n        \"\"\"\n        Parameters\n        ----------\n        topic : string, default: \"earthquakes-json\"\n            The name of the topic you wish to publish to. If the topic doesn't yet\n            exist, Ensign will create it for you. Tips on topic naming conventions can\n            be found at https://ensign.rotational.dev/getting-started/topics/\n\n        interval : int, default: 900\n            The number of seconds to wait between API calls so we don't irritate the\n            nice people at USGS.\n\n        user : str\n            When querying the USGS API, as a courtesy, they like you to identify your\n            app and contact info (aka User Agent details)\n        \"\"\"\n        self.topic = topic\n        self.interval = interval\n        self.url = \"https://earthquake.usgs.gov/fdsnws/event/1/query\"\n        self.user = {\"User-Agent\": user}\n        self.datatype = \"application/json\"\n\n        # NOTE: If you need a clientid and clientsecret, register for a free account\n        # at: https://rotational.app/register\n\n        # Start a connection to the Ensign server. If you do not supply connection\n        # details, PyEnsign will read them from your environment variables.\n        self.ensign = Ensign()\n\n        # Alternatively you can supply clientid & clientsecret as string args, eg\n        # self.ensign = Ensign(clientid=\"yourclientid\", clientsecret=\"your_secret\")\n\n    async def print_ack(self, ack):\n        \"\"\"\n        Enable the Ensign server to notify the Publisher the event has been acknowledged\n\n        This is optional for you, but can be very helpful for communication in\n        asynchronous contexts!\n        \"\"\"\n        ts = datetime.fromtimestamp(\n            ack.committed.seconds + ack.committed.nanos / 1e9)\n        print(f\"Event committed at {ts}\")\n\n    async def print_nack(self, nack):\n        \"\"\"\n        Enable the Ensign server to notify the Publisher the event has NOT been\n        acknowledged\n\n        This is optional for you, but can be very helpful for communication in\n        asynchronous contexts!\n        \"\"\"\n        print(f\"Event was not committed with error {nack.code}: {nack.error}\")\n\n    def compose_query(self):\n        \"\"\"\n        Combine the base URI with the time-related query params\n        Ask for only the data from the last 15 minutes\n\n        NOTE: There are other query params you can leverage to reduce the total results.\n        For example, you can add the minmagnitude param to only get results for bigger\n        earthquakes. Check out the docs for more details:\n        https://earthquake.usgs.gov/fdsnws/event/1/#parameters\n        \"\"\"\n        start = datetime.now() - timedelta(hours=0, minutes=15)\n        return self.url + \"?format=geojson\" + \"&starttime=\" + start.isoformat()\n\n    def unpackusgsresponse(self, message):\n        \"\"\"\n        Convert a message from the USGS API to potentially multiple Ensign events,\n        and yield each.\n\n        Parameters\n        ----------\n        message : dict\n            JSON formatted response from the USGS API containing forecast details\n        \"\"\"\n        geo_events = message.get(\"features\", None)\n        if geo_events is None:\n            raise Exception(\n                \"unexpected response from usgs request, no geo-events found\")\n        for geoevent in geoevents:\n            details = geo_event.get(\"properties\", None)\n            if details is None:\n                raise Exception(\n                    \"unable to parse usgs api response, no geo-event details found\")\n\n            # There's a lot available! For this example, we'll just parse out a few\n            # fields from the USGS API response:\n            data = {\n                \"magnitude\": details.get(\"mag\", None),\n                \"place\": details.get(\"place\", None),\n                \"time\": details.get(\"time\", None),\n                \"updated\": details.get(\"updated\", None),\n                \"article_link\": details.get(\"url\", None),\n                \"type\": details.get(\"type\", None),\n                \"rms\": details.get(\"rms\", None),\n                \"gap\": details.get(\"gap\", None),\n            }\n\n            yield Event(json.dumps(data).encode(\"utf-8\"), mimetype=self.datatype)\n\n    async def recvandpublish(self):\n        \"\"\"\n        At some interval (self.interval), ping the API to get any newly updated\n        events from the last interval period\n\n        Publish report data to the self.topic\n        \"\"\"\n        await self.ensign.ensuretopicexists(self.topic)\n\n        while True:\n            query = self.compose_query()\n            response = requests.get(query).json()\n\n            # unpack the API response and parse it into events\n            events = self.unpackusgsresponse(response)\n            for event in events:\n                await self.ensign.publish(\n                    self.topic,\n                    event,\n                    onack=self.printack,\n                    onnack=self.printnack,\n                )\n\n            # sleep for a bit before we ping the API again\n            await asyncio.sleep(self.interval)\n\n    def run(self):\n        \"\"\"\n        Run the publisher forever.\n        \"\"\"\n        asyncio.geteventloop().rununtilcomplete(self.recvandpublish())\n\nif name == \"main\":\n    publisher = EarthquakePublisher()\n    publisher.run()\n\n{{% /data-playground-code-tab %}}\n\n{{% data-playground-code-tab tabIndex=\"go\" name=\"Go\"  %}}\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Code snippet coming soon!\")\n}\n\n{{% /data-playground-code-tab %}}\n{{% /data-playground-code-tabs %}}\n\n{{% /data-playground-wrapper %}}\n\n{{% data-playground-content %}}\n\n!-- Add content for data playground here, including a table for data products if available --\n\n{{% /data-playground-content %}}\n\n{{% coming-soon %}}\n\nComing soon!\n\n{{% /coming-soon %}}\n",
        "tags": []
    }
]