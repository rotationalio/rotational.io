<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Rotational Labs</title><link>https://rotational.io/tags/golang/</link><description>Recent content in Golang on Rotational Labs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Jul 2023 09:39:09 -0500</lastBuildDate><atom:link href="https://rotational.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Speeding Up Go Tests</title><link>https://rotational.io/blog/speeding-up-go-tests/</link><pubDate>Sun, 30 Jul 2023 09:39:09 -0500</pubDate><guid>https://rotational.io/blog/speeding-up-go-tests/</guid><description>&lt;p&gt;It can be frustrating as a developer to wait for a large test suite to run, particularly when you have to run the suite multiple times in development. In this post, we&amp;rsquo;ll explore parallel and short modes with Go tests in an effort to improve local test speed and save longer running tests for CI.&lt;/p&gt;</description></item><item><title>Async or Swim: A Developer's Guide to Wading into Asynchronous Processing</title><link>https://rotational.io/blog/async-or-swim/</link><pubDate>Mon, 05 Jun 2023 10:39:51 -0500</pubDate><guid>https://rotational.io/blog/async-or-swim/</guid><description>&lt;p&gt;The Go programming language provides powerful tools for managing concurrency, but robust asynchronous code requires us as developers to design around uncertain tasks and manifold queues. Step through an async codebase with us in this post!&lt;/p&gt;</description></item><item><title>Mocking the Universe: Two Techniques for Testing gRPC with Mocks</title><link>https://rotational.io/blog/mocking-the-universe/</link><pubDate>Tue, 28 Mar 2023 13:29:11 -0400</pubDate><guid>https://rotational.io/blog/mocking-the-universe/</guid><description>&lt;p&gt;At Rotational, &lt;a href="https://rotational.io/blog/what-are-protocol-buffers/"&gt;we use gRPC&lt;/a&gt; &lt;a href="https://rotational.io/blog/documenting-grpc-with-openapi"&gt;quite a bit&lt;/a&gt;. It&amp;rsquo;s great for specifying network APIs, but can challenge us to find new ways to thoroughly test the code. Follow along with this post to learn two ways of using &lt;a href="https://rotational.io/blog/fake-it-when-you-make-it/"&gt;mocking&lt;/a&gt; to test gRPC services!&lt;/p&gt;</description></item><item><title>Ranges of Integer Data Types</title><link>https://rotational.io/blog/ranges-of-integer-data-types/</link><pubDate>Wed, 07 Sep 2022 09:40:12 -0500</pubDate><guid>https://rotational.io/blog/ranges-of-integer-data-types/</guid><description>&lt;p&gt;The data type choices we make when building data systems or metrics is critically important: as our systems run for long periods of time it can be easy to overflow the integers that we use (Y2K bug anyone?). As a result, I find myself constantly checking the sizes of standard int types but I haven&amp;rsquo;t found a good way to Google this. This blog post is a quick reference for the standard sizes and a discussion on why it matters.&lt;/p&gt;</description></item><item><title>Marshaling Go Enums to and from JSON</title><link>https://rotational.io/blog/marshaling-go-enums-to-and-from-json/</link><pubDate>Thu, 26 May 2022 08:50:04 -0500</pubDate><guid>https://rotational.io/blog/marshaling-go-enums-to-and-from-json/</guid><description>&lt;p&gt;Customizing JSON serialization for your data types seems relatively straightforward on the surface, but it&amp;rsquo;s easy to get turned around in receiver, value, pointer, and indirection confusion. Many of the patterns and rules-of-thumb you use in your normal Go code can lead you astray. In this post, we&amp;rsquo;ll illustrate exactly how and why to handle these edge cases.&lt;/p&gt;</description></item><item><title>Fake It When You Make It: Creating Mocks in Go</title><link>https://rotational.io/blog/fake-it-when-you-make-it/</link><pubDate>Mon, 06 Dec 2021 10:39:45 -0600</pubDate><guid>https://rotational.io/blog/fake-it-when-you-make-it/</guid><description>&lt;p&gt;In the age of microservices and containerized applications, software is less monolithic and more interdependent. How do we write tests which account for this new reality? One common strategy is to create mocks for services. In this post, we&amp;rsquo;ll explore some of the challenges with testing in Go and dive into some concrete examples where creating mocks can help alleviate these problems.&lt;/p&gt;</description></item><item><title>Using Google's Secret Manager API with Go</title><link>https://rotational.io/blog/secrets-manager-with-go/</link><pubDate>Tue, 01 Jun 2021 08:26:38 -0400</pubDate><guid>https://rotational.io/blog/secrets-manager-with-go/</guid><description>&lt;p&gt;Security is by definition an inconvenience. At the very least, it&amp;rsquo;s about making access to data as challenging as possible for the baddies, conveniently measured in computation time. But good security also requires us good folks to go above and beyond — adopting architectural and engineering practices that involve more forethought, more effort, and more testing than are strictly required to get a basic application running on the web. If you&amp;rsquo;re here already, we don&amp;rsquo;t need to convince you that the effort is well worth it; good security pays for itself in customer trust, not to mention helping to preclude the kinds of breaches that can get careless folks in hot water. In this post, we&amp;rsquo;ll dive into Google&amp;rsquo;s Secret Manager service, walk through the setup steps, and explore some Go code to interact with the API.&lt;/p&gt;</description></item><item><title>Contexts in Go Microservice Chains</title><link>https://rotational.io/blog/contexts-in-go-microservice-chains/</link><pubDate>Sun, 02 May 2021 14:24:33 -0400</pubDate><guid>https://rotational.io/blog/contexts-in-go-microservice-chains/</guid><description>&lt;p&gt;Contexts are a critical part of services implemented in Golang. Although we see them often in server interfaces, they can be mysterious to developers implementing request handlers. In this post, we&amp;rsquo;ll discuss what contexts are and take a look at a specific example where contexts shine: services that are implemented as a series of microservice requests. Then we&amp;rsquo;ll dive into the tl;dr of contexts — namely, the two crucial rules that all service handlers should implement. Finally, we&amp;rsquo;ll demonstrate a quick experiment using gRPC to show how context deadlines are propagated to downstream microservices during request processing, enabling effective coordination.&lt;/p&gt;</description></item><item><title>Documenting a gRPC API with OpenAPI</title><link>https://rotational.io/blog/documenting-grpc-with-openapi/</link><pubDate>Fri, 12 Feb 2021 17:45:35 +0000</pubDate><guid>https://rotational.io/blog/documenting-grpc-with-openapi/</guid><description>&lt;p&gt;gRPC makes the specification and implementation of networked APIs a snap. But what is the simplest way to &lt;em&gt;document&lt;/em&gt; a gRPC API? There seem to be some hosted providers by Google, e.g. &lt;a href="https://cloud.google.com/endpoints/docs/grpc/dev-portal-update-ref-docs"&gt;SmartDocs&lt;/a&gt;, but I have yet to find a gRPC-specific tool. For REST API frameworks, documentation is commonly generated along with live examples using &lt;a href="https://swagger.io/resources/open-api/"&gt;OpenAPI (formerly swagger)&lt;/a&gt;. By using &lt;a href="https://github.com/grpc-ecosystem/grpc-gateway"&gt;grpc-gateway&lt;/a&gt; it appears to be pretty straight forward to generate a REST/gRPC API combo from protocol buffers and then hook into the OpenAPI specification.&lt;/p&gt;</description></item></channel></rss>